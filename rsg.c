/* File: rsg.c * -------------- * This program generates random sentences according to  * the form of a simple grammar file supplied by the user. */#include <stdio.h>#include <stdlib.h>		// for malloc()#include <stdarg.h>#include <sys/types.h>  // for time.h#include <time.h>       // to generate srandom() seed#include <limits.h>		// for PATH_MAX#include <ctype.h>#include <string.h>		// for strcasecmp()#include <assert.h>#include "scanner.h"#include "hashtable.h"#include "darray.h"#define WHITE_SPACE				            " \t\n\r"#define DEFINITION_START		            "{"#define DEFINITION_END			            "}"#define NONTERMINAL_START		            '<'#define NONTERMINAL_END                     '>'#define PRODUCTION_END			            ";"#define MAX_TOKEN_LEN			            128#define DEFAULT_DEFINITIONS                 16#define DEFAULT_PRODUCTIONS		            4#define DEFAULT_TOKENS                      2#define NUM_EXPANSIONS                      3#define EXPANSION_START                     "<start>"#define NEEDS_SPACE                         "(_^*/+-"   // punctuation that needs leading space#define EATS_SPACE                          "("         // punctuation that eats following space#define STRMATCH(str1, str2)                (strcasecmp(str1, str2) == 0)#define CHRMATCH(str, chr)                  (strchr(str, chr) != NULL)#define STRTAGGED(str, chrBegin, chrEnd)    (str[0] == chrBegin && str[(strlen(str) - 1)] == chrEnd)#define SEED                                (argc > 2 ? atoi(argv[2]) : time(NULL))struct Definition {	char		*label;         // nonterminal text	DArray		prods;          // array of productions for text};struct Production {	DArray		tokens;         // array of tokens for production};struct Token {	char		*text;          // text of token	bool        nonterminal;    // true if nonterminal};static void     ParseGrammar(Scanner grammarScanner, HashTable grammarTable);static void     ExpandDefinition(void *elem, void *clientData);static void     PrintToken(struct Token *tokenPtr);static int      DefinitionHash(const void *elem, int numBuckets);static int      DefinitionCompare(const void *entry1, const void *entry2);static void     DefinitionFree(void *elem);static void     ProductionFree(void *elem);static void     TokenFree(void *elem);static int      StringHash(const char *s, int numBuckets);static char     *CopyString(const char *s);static void     PrintWithWrap(FILE *out, const char *format, ...);int main(int argc, char *argv[]){	Scanner         grammarScanner;	HashTable       grammarTable;	int             i;	struct Token    expStart = {EXPANSION_START, true};	if (argc < 2) {		PrintWithWrap(stdout, "OOPS! This program takes one argument which is the grammar file to read from. Please try again!\n");    } else {		grammarScanner = NewScannerFromFilename(argv[1], WHITE_SPACE, true);		if (grammarScanner == NULL) {			PrintWithWrap(stdout, "I'm sorry, I can't seem to open the file named \"%s\". Please try again!\n", argv[1]);        } else {			grammarTable = TableNew(sizeof(struct Definition), DEFAULT_DEFINITIONS, DefinitionHash, DefinitionCompare, DefinitionFree);            ParseGrammar(grammarScanner, grammarTable);            FreeScanner(grammarScanner);            srandom(SEED);            for (i = 1; i <= NUM_EXPANSIONS; i++) {                PrintWithWrap(stdout, "Version #%d: ----------------------------\n    ", i);                ExpandDefinition(&expStart, grammarTable);                PrintWithWrap(stdout, "\n\n");            }            TableFree(grammarTable);		}	}	return 0;}/* ParseGrammar * ------------ * This is implemented with a single ReadNextToken loop and a  * state machine to parse the grammar file according to the rules. */static void ParseGrammar(Scanner grammarScanner, HashTable grammarTable){	char				tokenBuffer[MAX_TOKEN_LEN];	int                 state;	enum                { readdef, readlabel, readprod, readterm };	struct Definition	newDef;	struct Production	newProd;	struct Token		newToken;	    SkipUntil(grammarScanner, DEFINITION_START);    state = readdef;    while (ReadNextToken(grammarScanner, tokenBuffer, MAX_TOKEN_LEN))         switch (state) {        case readdef:            if (STRMATCH(tokenBuffer, DEFINITION_START)) {                newDef.label = NULL;                newDef.prods = ArrayNew(sizeof(struct Production), DEFAULT_PRODUCTIONS, ProductionFree);                state = readlabel;            }            break;        case readlabel:            newDef.label = CopyString(tokenBuffer);            TableEnter(grammarTable, &newDef);            state = readprod;            break;        case readprod:            if (STRMATCH(tokenBuffer, DEFINITION_END)) {                SkipUntil(grammarScanner, DEFINITION_START);                state = readdef;                break;            }            newProd.tokens = ArrayNew(sizeof(struct Token), DEFAULT_TOKENS, TokenFree);            ArrayAppend(newDef.prods, &newProd);            state = readterm;            // falls through to next case...        case readterm:            if (STRMATCH(tokenBuffer, PRODUCTION_END)) {                state = readprod;                break;            }            newToken.text = CopyString(tokenBuffer);            newToken.nonterminal = STRTAGGED(tokenBuffer, NONTERMINAL_START, NONTERMINAL_END);            ArrayAppend(newProd.tokens, &newToken);        }}/* ExpandDefinition * ---------------- * This function calls ArrayMap on itself :P */static void ExpandDefinition(void *elem, void *clientData){    struct Token        *tokenPtr = (struct Token *)elem;    HashTable           tablePtr = (HashTable)clientData;    struct Definition   *defPtr, newDef;    struct Production   *prodPtr;    int                 numProds;        if (tokenPtr->nonterminal) {        newDef.label = tokenPtr->text;        newDef.prods = NULL;        defPtr = (struct Definition *)TableLookup(tablePtr, &newDef);        assert(defPtr != NULL);        numProds = ArrayLength(defPtr->prods);        if (numProds > 0) {            // pick a valid random production	        prodPtr = (struct Production *)ArrayNth(defPtr->prods, random() % numProds);	        ArrayMap(prodPtr->tokens, ExpandDefinition, tablePtr);         }    } else {        PrintToken(tokenPtr);    }}/* PrintToken * ---------- * This function prints tokens according to somewhat improved spacing rules. */static void PrintToken(struct Token *tokenPtr){    char        c = tokenPtr->text[0];    static bool eatspace = false;        if (!eatspace)        if (CHRMATCH(NEEDS_SPACE, c) || !ispunct(c)) PrintWithWrap(stdout, " ");    eatspace = CHRMATCH(EATS_SPACE, c) && strlen(tokenPtr->text) == 1;    PrintWithWrap(stdout, tokenPtr->text);}static int DefinitionHash(const void *elem, int numBuckets){    struct Definition   *d = (struct Definition *)elem;        return StringHash(d->label, numBuckets);}static int DefinitionCompare(const void *entry1, const void *entry2){    struct Definition   *d1 = (struct Definition *)entry1,                         *d2 = (struct Definition *)entry2;        return strcasecmp(d1->label, d2->label);}static void DefinitionFree(void *elem){    struct Definition   *d = (struct Definition *)elem;        if (d != NULL) {        if (d->prods != NULL)            ArrayFree(d->prods);        if (d->label != NULL)            free(d->label);    }}static void ProductionFree(void *elem){    struct Production   *p = (struct Production *)elem;        if (p != NULL)	    if (p->tokens != NULL)	        ArrayFree(p->tokens);}static void TokenFree(void *elem){    struct Token   *t = (struct Token *)elem;        if (t != NULL)	    if (t->text != NULL)	        free(t->text);}#define MULTIPLIER		-1664117991static char safetolower(char ch){	return (isascii(ch) ? tolower(ch) : ch);}/* StringHash * ---------- * This function adapted from Eric Roberts' _The Art and Science of C_ * It takes a string and uses it to derive a "hash code," which  * is an integer in the range [0..NumBuckets-1]. The hash code is computed * using a method called "linear congruence." A similar function using this * method is described on page 144 of Kernighan and Ritchie. The choice of * the value for the Multiplier can have a significant effort on the * performance of the algorithm, but not on its correctness. * This hash function has the additional feature of being case-insensitive, * hashing "ZELENSKI" and "Zelenski" to the same code. */static int StringHash(const char *s, int numBuckets){	int				i;	unsigned long	hashcode = 0;		for (i = 0; i < strlen(s); i++)		hashcode = hashcode * MULTIPLIER + safetolower(s[i]);	return (hashcode % numBuckets);}/* CopyString * ---------- * Straight-forward utility function to make a new heap copy of a string. */static char *CopyString(const char *s){	char	*copy = malloc(strlen(s) + 1);		assert(copy != NULL);	strcpy(copy, s);	return copy;}/*  * PrintWithWrap * ------------- * This is structured like an fprintf function, you pass the FILE * to write to, the format string, and then any number of matchings * arguments for the format string.	 The only difference is that it * internally tracks how many characters are on the current line and * when getting to close to the end, finds a convenient space character * and turns it into a newline to get new line-wrapping output. */static void PrintWithWrap(FILE *out, const char *format, ...) {	#define WRAP_COLUMN 65	static int column = 0;	// keeps track of how many characters on this line	char buffer[1024];	int i, len;	va_list ap;	va_start(ap, format);	vsprintf(buffer, format, ap);	va_end(ap);	len = strlen(buffer);		for (i = 0; i < len; i++) {	  if ((column > WRAP_COLUMN) && isspace(buffer[i])) {		 fprintf(out, "\n");		// change space to return 		 column = 0;			// re-start counter	  } else {	// otherwise just print it normally and				// keep our internal column number in sync		fputc(buffer[i], out);		column++;		if (buffer[i]=='\n') column = 0;	  }   }}