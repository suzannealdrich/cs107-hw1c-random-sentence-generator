/* File: hashtable.c * ----------------- * Implementation of hashtable interface. */#include <assert.h>#include <stdlib.h>#include <string.h>#include "hashtable.h"#include "darray.h"#define DEFAULT_ELEMS 2struct HashImplementation {    DArray              *buckets;    int                 nBuckets;       // number of buckets    int                 elemSize;       // byte size of each element    TableHashFn         hashFn;         // client element hash function    TableCompareFn      compFn;         // client element compare function    TableElementFreeFn  freeFn;         // client element clean up function};HashTable TableNew(int elemSize, int nBuckets, TableHashFn hashFn, TableCompareFn compFn, TableElementFreeFn freeFn){    HashTable       table;    DArray          *buckets;    int             n;        assert(elemSize > 0);    assert(nBuckets > 0);    assert(hashFn != NULL);    assert(compFn != NULL);        // allocate memory for table structure and its buckets        table = malloc(sizeof(struct HashImplementation));    assert(table != NULL);    buckets = malloc(nBuckets * sizeof(DArray *));    assert(buckets != NULL);    for (n = 0; n < nBuckets; n++)        buckets[n] = NULL;        // initialize table structure        table->buckets = buckets;    table->nBuckets = nBuckets;    table->elemSize = elemSize;    table->hashFn = hashFn;    table->compFn = compFn;    table->freeFn = freeFn;        return table;   }void TableFree(HashTable table){    int     n;        assert(table != NULL);    assert(table->buckets != NULL);        for (n = table->nBuckets-1; n >= 0; n--)        if (table->buckets[n] != NULL)            ArrayFree(table->buckets[n]);                free(table->buckets);    free(table);}int TableCount(HashTable table){    int     n;    int     count = 0;        assert(table != NULL);    assert(table->buckets != NULL);        // count the number of entries in each bucket        for (n = 0; n < table->nBuckets; n++)        if (table->buckets[n] != NULL)            count += ArrayLength(table->buckets[n]);            return count;}void TableEnter(HashTable table, const void *newElem){    int     hashBucket;    int     bucketElem;        assert(table != NULL);        // determine which bucket to put new element in        hashBucket = (*table->hashFn)(newElem, table->nBuckets);        // if the bucket is empty, make new list for new element        if (table->buckets[hashBucket] == NULL) {        table->buckets[hashBucket] = ArrayNew(table->elemSize, DEFAULT_ELEMS, table->freeFn);        assert(table->buckets[hashBucket] != NULL);    }        // determine which matched element to replace    // or append unique element to the end of the list        bucketElem = ArraySearch(table->buckets[hashBucket], newElem, table->compFn, 0, false);        if (bucketElem == NOT_FOUND)        ArrayAppend(table->buckets[hashBucket], newElem);    else        ArrayReplaceAt(table->buckets[hashBucket], newElem, bucketElem);}void *TableLookup(HashTable table, const void *elemKey){    int     hashBucket;    int     bucketElem;        assert(table != NULL);    assert(elemKey != NULL);            // determine which bucket to search for key element        hashBucket = (*table->hashFn)(elemKey, table->nBuckets);        // if the bucket is empty, key element is not found        if (table->buckets[hashBucket] == NULL)         return NULL;        // find element in bucket which matches key element        bucketElem = ArraySearch(table->buckets[hashBucket], elemKey, table->compFn, 0, false);        if (bucketElem == NOT_FOUND)        return NULL;            return ArrayNth(table->buckets[hashBucket], bucketElem);    }void TableMap(HashTable table, TableMapFn fn, void *clientData){    int     n;        assert(table != NULL);    assert(fn != NULL);        // iterate over all buckets and over their lists of elements         for (n = 0; n < table->nBuckets; n++)        if (table->buckets[n] != NULL)            ArrayMap(table->buckets[n], fn, clientData);}