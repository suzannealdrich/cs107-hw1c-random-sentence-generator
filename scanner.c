/* File: scanner.c * --------------- * Implementation of scanner.h */#include <assert.h>#include <stdlib.h>#include <string.h>#include "scanner.h"struct ScannerImplementation {    FILE	*fp;                // input stream    char    *delimiters;        // set of possible delimeter characters    bool    discardDelimiters;  // eat delimiters if true; return them if false    bool    openedFile;         // opened file if true; passed stream if false};static Scanner NewScanner(FILE *fp, const char *delimiters, bool discardDelimiters, bool openedFile){    Scanner     s;        if (fp == NULL) return NULL;    assert(delimiters != NULL);        // allocate memory for scanner        s = malloc(sizeof(struct ScannerImplementation));    assert(s != NULL);    s->delimiters = malloc(strlen(delimiters) + 1);    assert(s->delimiters != NULL);        // initialize        s->fp = fp;    strcpy(s->delimiters, delimiters);    s->discardDelimiters = discardDelimiters;    s->openedFile = openedFile;    return s;}Scanner NewScannerFromFilename(const char *filename, const char *delimiters, bool discardDelimiters){    return NewScanner(fopen(filename, "r"), delimiters, discardDelimiters, true);}Scanner NewScannerFromFile(FILE *fp, const char *delimiters, bool discardDelimiters){       return NewScanner(fp, delimiters, discardDelimiters, false);}void FreeScanner(Scanner s){    // free memory for scanner        assert(s != NULL);    if (s->delimiters != NULL) free(s->delimiters);    if (s->openedFile && s->fp != NULL) fclose(s->fp);    free(s);}bool ReadNextToken(Scanner s, char buffer[], int bufLen){    int     tokenlength = 0;        // number of accumulated characters    int     c;                      // current character    bool    isDelimiter;            // true if current character is a delimiter        assert(s != NULL);    assert(buffer != NULL);        // eat leading delimiters        if (s->discardDelimiters) SkipOver(s, s->delimiters);        // keep reading characters until buffer fills or EOF    while ((tokenlength + 1 < bufLen) && ((c = fgetc(s->fp)) != EOF)) {        isDelimiter = strchr(s->delimiters, c) != NULL;        if (isDelimiter && tokenlength > 0) {       // end of a token            ungetc(c, s->fp);            break;                                  // return token        }        buffer[tokenlength++] = c;        buffer[tokenlength] = '\0';        if (isDelimiter) break;                     // return single delimiter token    }        // true if token found; false if EOF        return (tokenlength > 0);}static int Skip(Scanner s, const char *set, bool skipMembers){    int     c;          // current character    bool    isMember;   // true if current character is a member of set    bool    doSkip;     // true if current character should be skipped    assert(s != NULL);    assert(set != NULL);    // keep reading characters until EOF    while ((c = fgetc(s->fp)) != EOF) {        isMember = strchr(set, c) != NULL;                // when skipMembers is true, skip members; otherwise, skip non-members                doSkip = (skipMembers ? isMember : !isMember);        if (doSkip == false) {            ungetc(c, s->fp);       // push back boundary character            break;                  // done skipping        }    }        return c;                       // return boundary character}int SkipOver(Scanner s, const char *skipSet){    return Skip(s, skipSet, true);      // skip characters occuring in skipSet}int SkipUntil(Scanner s, const char *untilSet){    return Skip(s, untilSet, false);    // skip characters not occuring in untilSet}